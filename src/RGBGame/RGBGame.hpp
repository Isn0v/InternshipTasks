#pragma once
#include <cstddef>
#include <iostream>
#include <sstream>
#include <unordered_map>

#define FIELD_WIDTH 15
#define FIELD_HEIGHT 10

namespace RGB_Game {

class Point {
 private:
  std::size_t x_, y_;

 public:
  std::size_t x() const;
  std::size_t y() const;

  Point() = default;
  Point(std::size_t x, std::size_t y);
  Point(const Point &point);
  Point &operator=(const Point &point);

  bool operator==(const Point &point) const;
  bool operator!=(const Point &point) const;

  friend std::ostream &operator<<(std::ostream &os, const Point &wall);
};

struct PointHash {
  std::size_t operator()(const Point &point) const;
};

/**
 * @brief Disjoint Set Union data structure.
 *
 * Disjoint Set Union is a data structure that allows to efficiently manage
 * disjoint sets (sets where there is no element that belongs to both sets).
 * It is commonly used in algorithms that deal with connectivity (e.g., finding
 * connected components in a graph).
 *
 * This class implements the basic operations of the Disjoint Set Union data
 * structure: make_union, get_root, and get_cluster_size.
 */
class DSU {
 private:
  std::size_t parent[FIELD_HEIGHT * FIELD_WIDTH];
  std::size_t rank[FIELD_HEIGHT * FIELD_WIDTH];
  std::unordered_map<std::size_t, std::size_t> root_to_cluster_size;

  void init();

 public:
  DSU();

  /**
   * @brief Resets the Disjoint Set Union data structure.
   *
   * Resets the parent and rank arrays, and clears the size of each cluster.
   */
  void reset();

  void make_union(std::size_t i1, std::size_t i2);

  std::size_t get_root(std::size_t i);

  std::size_t get_cluster_size(std::size_t i);

  auto get_cluster_sizes() const;

  friend class RGB_Game;
};

/**
 * @brief RGB Game class.
 *
 * This class encapsulates the logic of the RGB Game. It provides methods to
 * initialize the game field, play the game, and retrieve the game log.
 */
class RGB_Game {
 private:
  DSU field_dsu;
  char game_field[FIELD_HEIGHT][FIELD_WIDTH];
  std::size_t total_score = 0;
  std::stringstream game_log;

  bool out_of_field(const Point &point);

  std::size_t count_balls_on_field();

  Point choose_move();

  void clusterize_field();
  void update_field();
  void update();
  void make_move(std::size_t move_count, const Point &point);

 public:
  RGB_Game(char (&field)[FIELD_HEIGHT][FIELD_WIDTH]);

  auto get_field();

  void play();

  /**
   * @brief Dumps the game log in format:
   *
   * Move i at (j, k) : removed n balls of color c, got p points
   * Final score: s with n balls remaining (at the end)
   *
   * @return The game log.
   */
  std::string dumps_log();
};

/**
 * @brief Parses the input string and handles the RGB Game based on the
 * provided input.
 *
 * @param input The input string containing the game field information.
 *
 * @return The game log generated by the RGB Game.
 *
 * The input string is expected to be in the following format:
 * [NUMBER_OF_GAMES]
 * and then each game field:
 * [R][G][B][R][G][B]...[R][G][B] (FIELD_WIDTH * FIELD_HEIGHT size)
 * where each character represents a color (R, G, or B) in the game field.
 *
 * The function initializes the game field based on the input string and
 * plays the RGB Game. It then dumps the game log in the format specified
 * in the RGB_Game class documentation.
 */
std::string handle_rgb_game(const std::string &input);

}  // namespace RGB_Game